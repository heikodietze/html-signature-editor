<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML Signature Editor v2.01</title>

    <!-- Tailwind CSS via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js"></script>
    <!-- js-beautify for beautifying HTML -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-beautify/1.14.0/beautify-html.min.js"></script>

    <style>
        /* Griffleiste für Größenänderung */
        #resizer {
            width: 5px;
            background-color: #ddd;
            cursor: col-resize;
            height: 100%;
            position: relative;
        }

        /* Entferne unerwünschte Umrandungen */
        *:focus {
            outline: none !important;
        }
    </style>
</head>
<body class="bg-gray-100 font-sans leading-normal tracking-normal">

    <header class="bg-white shadow p-6">
        <h1 class="text-2xl font-semibold text-gray-800 text-center">HTML Signature Editor <span class="text-gray-500">v2.01</span></h1>
    </header>

    <!-- Styling Controls -->
    <div id="controls" class="flex justify-center space-x-4 my-6">
        <button class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-500" onclick="wrapText('b')">Fett</button>
        <button class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-500" onclick="wrapText('i')">Kursiv</button>
        <button class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-500" onclick="addLink()">Link</button>
        <button class="px-4 py-2 bg-purple-600 text-white rounded hover:bg-purple-500" onclick="beautifyCode()">Beautify</button>
        <button class="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-500" onclick="undo()">Undo</button>
        <button class="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-500" onclick="redo()">Redo</button>
        <button class="px-4 py-2 bg-orange-600 text-white rounded hover:bg-orange-500" onclick="resetPanels()">Reset Panels</button>
        <input type="color" id="textColor" class="px-2 py-2 border border-gray-300 rounded" value="#000000" onchange="changeTextColor()">
        <label for="textColor" class="text-gray-700">Textfarbe</label>
        <input type="color" id="bgColor" class="px-2 py-2 border border-gray-300 rounded" value="#ffffff" onchange="changeBgColor()">
        <label for="bgColor" class="text-gray-700">Hintergrundfarbe</label>
    </div>

    <!-- Container für Textfeld, Vorschau und Griffleiste -->
    <div id="container" class="flex h-[calc(100vh-200px)] px-6">
        <pre class="w-1/2 bg-white border border-gray-300 p-4 rounded-lg shadow-sm overflow-auto"><code id="htmlInput" class="language-html" contenteditable="true" style="white-space: pre-wrap;"></code></pre>
        <div id="resizer"></div>
        <iframe id="preview" class="w-1/2 bg-white border border-gray-300 rounded-lg shadow-sm"></iframe>
    </div>

    <!-- Fixierte Buttons am unteren Rand -->
    <div id="action-buttons" class="fixed bottom-0 w-full bg-white shadow p-4 text-center space-x-4">
        <button class="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-500" onclick="copyToClipboard()">Code kopieren</button>
        <button class="px-4 py-2 bg-yellow-600 text-white rounded hover:bg-yellow-500" onclick="validateHTML()">HTML validieren</button>
        <button class="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-500" onclick="toggleMobileView()">Mobile Vorschau umschalten</button>
    </div>

    <script>
        let undoStack = [];
        let redoStack = [];
        const maxStackSize = 50;  // Maximal 50 Aktionen speichern

        // Funktion für Live-Vorschau
        function updatePreview() {
            const htmlCode = document.getElementById("htmlInput").innerText;  // Verwende innerText statt textContent für bessere Cursor-Position
            const previewFrame = document.getElementById("preview");
            const preview = previewFrame.contentDocument || previewFrame.contentWindow.document;
            preview.open();
            preview.write(htmlCode);
            preview.close();

            // Syntax Highlighting neu anwenden
            Prism.highlightAll();
        }

        // Speichern des aktuellen Zustands im Undo-Stack
        function saveState() {
            const currentContent = document.getElementById("htmlInput").innerText;
            if (undoStack.length >= maxStackSize) {
                undoStack.shift();  // Entferne den ältesten Eintrag, um Speicherplatz zu schaffen
            }
            undoStack.push(currentContent);
            redoStack = [];  // Redo-Stack zurücksetzen, wenn eine neue Änderung gemacht wird
        }

        // Undo-Funktion
        function undo() {
            if (undoStack.length > 0) {
                const currentContent = document.getElementById("htmlInput").innerText;
                redoStack.push(currentContent);  // Aktuellen Zustand im Redo-Stack speichern
                const previousContent = undoStack.pop();  // Letzte Aktion aus dem Undo-Stack
                document.getElementById("htmlInput").innerText = previousContent;
                updatePreview();  // Vorschau aktualisieren
            }
        }

        // Redo-Funktion
        function redo() {
            if (redoStack.length > 0) {
                const currentContent = document.getElementById("htmlInput").innerText;
                undoStack.push(currentContent);  // Aktuellen Zustand im Undo-Stack speichern
                const nextContent = redoStack.pop();  // Nächste Aktion aus dem Redo-Stack
                document.getElementById("htmlInput").innerText = nextContent;
                updatePreview();  // Vorschau aktualisieren
            }
        }

        document.getElementById("htmlInput").addEventListener("input", () => {
            saveState();  // Speichere Zustand nach jeder Eingabe
            updatePreview();  // Vorschau aktualisieren
        });

        // Funktion zum Kopieren des HTML-Codes in die Zwischenablage
        function copyToClipboard() {
            const htmlCode = document.getElementById("htmlInput").innerText;
            navigator.clipboard.writeText(htmlCode).then(function() {
                alert("HTML-Code in die Zwischenablage kopiert!");
            }, function(err) {
                alert("Fehler beim Kopieren: " + err);
            });
        }

        // Funktion zum Einfügen von HTML-Tags
        function wrapText(tag) {
            const textarea = document.getElementById("htmlInput");
            const start = window.getSelection().anchorOffset;
            const end = window.getSelection().focusOffset;
            const text = textarea.innerText.substring(start, end);
            const before = textarea.innerText.substring(0, start);
            const after = textarea.innerText.substring(end);
            textarea.innerText = before + `<${tag}>` + text + `</${tag}>` + after;
            updatePreview();
        }

        // Funktion zum Hinzufügen eines Links
        function addLink() {
            const url = prompt("Gib die URL ein:");
            if (url) {
                wrapText(`a href="${url}"`);
            }
        }

        // Funktion zur Änderung der Textfarbe
        function changeTextColor() {
            const color = document.getElementById("textColor").value;
            wrapText(`span style="color:${color}"`);
        }

        // Funktion zur Änderung der Hintergrundfarbe
        function changeBgColor() {
            const color = document.getElementById("bgColor").value;
            wrapText(`span style="background-color:${color}"`);
        }

        // Funktion zur Validierung des HTML-Codes
        function validateHTML() {
            const htmlCode = document.getElementById("htmlInput").innerText;
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlCode, 'text/html');
            const errors = doc.getElementsByTagName('parsererror');

            if (errors.length > 0) {
                alert("Fehler im HTML: " + errors[0].textContent);
            } else {
                alert("HTML ist gültig!");
            }
        }

        // Funktion zur Beautifizierung des HTML-Codes
        function beautifyCode() {
            const htmlInput = document.getElementById("htmlInput");
            const originalHTML = htmlInput.innerText;

            // Beautify HTML mit js-beautify
            const formattedHTML = html_beautify(originalHTML, {
                indent_size: 2,
                preserve_newlines: false,
                max_preserve_newlines: 0
            });

            htmlInput.innerText = formattedHTML;
            updatePreview();
        }

        // Funktion zur Umschaltung der mobilen Vorschau
        function toggleMobileView() {
            const previewFrame = document.getElementById("preview");
            const isMobile = previewFrame.classList.toggle("mobile-view");
            const preview = previewFrame.contentDocument || previewFrame.contentWindow.document;
            if (isMobile) {
                previewFrame.style.width = "375px";
                previewFrame.style.height = "667px";
            } else {
                previewFrame.style.width = "100%";
                previewFrame.style.height = "100%";
            }
        }

        // Funktion zur Größenänderung der Fenster mit Griffleiste
        const resizer = document.getElementById('resizer');
        const leftPanel = document.querySelector('pre');
        const rightPanel = document.getElementById('preview');
        let isResizing = false;

        resizer.addEventListener('mousedown', (e) => {
            isResizing = true;
            document.body.style.cursor = 'col-resize';
        });

        document.addEventListener('mousemove', (e) => {
            if (isResizing) {
                const containerWidth = document.getElementById('container').offsetWidth;
                const leftWidth = (e.pageX / containerWidth) * 100;
                const rightWidth = 100 - leftWidth;

                // Update both panel sizes only if within boundaries
                if (leftWidth >= 10 && rightWidth >= 10) {
                    leftPanel.style.width = `${leftWidth}%`;
                    rightPanel.style.width = `${rightWidth}%`;
                }
            }
        });

        document.addEventListener('mouseup', () => {
            isResizing = false;
            document.body.style.cursor = 'default';
        });

        // Funktion zum Zurücksetzen der Fenster auf die Standardgröße
        function resetPanels() {
            leftPanel.style.width = "50%";
            rightPanel.style.width = "50%";
        }

    </script>

</body>
</html>
